#+TITLE: nonk123's GNU/Emacs configuration
#+AUTHOR: nonk123

* Initialization

Functions like =modal-combo= break when a lexical argument (=key=) is
not available within the closure, which is why this configuration
requires lexical binding.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

* Utilities

Various utilities must be defined before loading external packages.

** Keymap Functions

There is not much to explain: =bind= and =unbind= modify keymaps. See
documentation for more info.

#+BEGIN_SRC emacs-lisp
(defun unbind (keymap &rest keys)
  "Unbind KEYS from a KEYMAP."
  (dolist (key keys)
    (define-key keymap (kbd key) nil)))

(defun bind (keymap keys-alist)
  "Bind keys from KEYS-ALIST onto KEYMAP and return it.

CAR is a key description.  CDR is one of the following:
 * Command name as a symbol, or a lambda (CAR is bound to CDR).
 * A key description (CAR is an alias to CDR).
 * Another keys-alist (CAR is a prefix key)."
  (pcase-dolist (`(,key . ,def) keys-alist keymap)
    (setq key (kbd key))
    (cl-typecase def
      (string ; key description
       (define-key keymap key (kbd def)))
      ((or symbol function keymap) ; command
       (define-key keymap key def))
      (t ; keys-alist (a prefix)
       (let* ((prefix (lookup-key keymap key))
              (prefix (or (and (keymapp prefix) prefix)
                          (make-sparse-keymap))))
         (define-key keymap key (bind prefix def)))))))
#+END_SRC

** Shell

=sh= runs shell commands, starting a _login_ shell. This ensures the
execution of =~/.bashrc=.

#+BEGIN_SRC emacs-lisp
  (defun sh (cmd &optional destination pwd)
    "Run CMD using the default shell.

  DESTINATION is passed to `call-process'.

  If PWD is specified, use that as the `default-directory', instead of \"~\"."
    (interactive)
    (let ((default-directory (or pwd "~")))
      (call-process (getenv "SHELL") nil destination nil "-l" "-c" cmd)))
#+END_SRC

** Prompt

Elisp backend for the =prompt= script.

#+BEGIN_SRC emacs-lisp
  (defun prompt--action (_candidates)
    "Output marked candidates, each on its own line.

  Used internally in function `prompt'."
    (with-output-to-string
      (mapc #'princ (helm-marked-candidates))
      (princ "\n")))

  (defun prompt (msg file)
    "Show a prompt, using candidates from FILE and MSG as the prompt message."
    (interactive)
    (helm :prompt msg
          :candidate-number-limit 250
          :buffer (format "*%s*" msg)
          :sources (helm-build-sync-source msg
                     :action #'prompt--action
                     :candidates
                     (if (file-exists-p file)
                         (with-temp-buffer
                           (insert-file-contents file)
                           ;; Each candidate on a separate line.
                           (split-string (buffer-string) "\n" t))
                       (error (format "File doesn't exist: %s" file))))))
#+END_SRC

** Symbol Concat

Function =s-concat= allows concatenating symbols like strings.

#+BEGIN_SRC emacs-lisp
  (defun symbol-to-string (x)
    "Convert X (a symbol) to string unless it already is a string."
    (if (stringp x)
        x
      (symbol-name x)))

  (defun s-concat (&rest symbols)
    "Concatenate SYMBOLS into one big symbol.

  Each entry in SYMBOLS is either a string or a symbol."
    (intern (string-join (mapcar #'symbol-to-string symbols) "")))
#+END_SRC

** Make Temporary Files

=mktemp= is a shorthand for =make-temp-file=. The name is derived from
=mktemp= command.

#+BEGIN_SRC emacs-lisp
  (defun mktemp (filename &optional contents)
    "Create FILENAME in temporary directory, suffixed with random garbage.

  Insert CONTENTS if non-nil.

  Return the created file's name like `make-temp-file' (which see)."
    (make-temp-file filename nil nil contents))
#+END_SRC

** Set to Default

=set-to-default= resets buffer-local variables. =reset-variable= is its
interactive counterpart.

#+BEGIN_SRC emacs-lisp
  (defun set-to-default (&rest variables)
    "Reset VARIABLES to their default values."
    (dolist (variable variables)
      (set variable (default-value variable))))

  (defun reset-variable ()
    "Interactive version of `set-to-default' (which see).

  Prompt the user to select a buffer-local variable, and reset its value."
    (interactive)
    (when-let* ((symbol (completing-read
                         "Reset value of: "
                         ;; Taken straight from help-fns.el:
                         #'help--symbol-completion-table
                         (lambda (var)
                           (and (or (get var 'variable-documentation)
                                    (and (boundp var) (not (keywordp var))))
                                ;; Slight modification: `default-value' works
                                ;; on buffer-local variables only.
                                (local-variable-p var))))))
      (set-to-default (intern symbol))))
#+END_SRC

** Miscellaneous

Not much to say here. These functions are used exactly once.

#+BEGIN_SRC emacs-lisp
  (defun list-directories-recursively (start)
    "List all directories in directory START recursively."
    (seq-filter #'file-directory-p (directory-files-recursively start ".+" t)))

  (defun append-nested (&rest sequences)
    "Join the nested lists inside each element of SEQUENCES, akin to `append'."
    (let ((result (list)))
      (dolist (sequence sequences (reverse result))
        (dolist (nested sequence)
          (dolist (elt nested)
            (push elt result))))))
#+END_SRC

* Packages

External packages are loaded with =use-package=. It is installed on
first run in =init.el=.

** Delight

Delight modifies modes' lighters. Only useful for =use-package=.

#+BEGIN_SRC emacs-lisp
  (use-package delight)
#+END_SRC

** Helm

Helm introduces interactive selection prompts and comes with various
supplement packages.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand
    :delight (helm-mode) (helm-ff-cache-mode)
    :init (require 'helm-config)
    :config (helm-mode 1)
    :bind (("M-x"     . helm-M-x)
           ("C-x b"   . helm-buffers-list)
           ("C-c M-x" . execute-extended-command)
           ("C-x C-f" . helm-find-files)))
  (use-package helm-swoop
    :after (helm projectile))
  (use-package helm-ag
    :after helm)
  (use-package helm-xref
    :after helm)
#+END_SRC

** Avy

Avy allows jumping anywhere in the buffer in few keystrokes. Seldom
used, but is fun.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :init (setq avy-keys '(?h ?j ?k ?l ?a ?s ?d ?f)))
#+END_SRC

** Magit

A Git portmanteau. Currently used for rebasing and editing commit
messages.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
#+END_SRC

** Company

"Complete anything" framework, the glue for many of the available
backends.

=company-flyspell= is one hell of a homebrew; seldom used.

External program backends are disabled for performance reasons.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :init (setq company-idle-delay nil)
    :config
    (defun company-flyspell (command &optional value &rest _args)
      (pcase command
        ('prefix (when-let ((word (car (ispell-get-word nil)))) word))
        ('candidates
         (ispell-send-string "%\n")
         (ispell-send-string (concat "^" value "\n"))
         (while (progn
                  (ispell-accept-output)
                  (not (string= "" (car ispell-filter)))))
         (setq ispell-filter (cdr ispell-filter))
         (when (and ispell-filter (listp ispell-filter))
           (let ((result (ispell-parse-output (car ispell-filter))))
             (if (listp result)
                 (append (caddr result) (caddr result))
               '()))))))
    (dolist (disabled '(company-eclim company-clang company-xcode company-dabbrev))
      (setq company-backends (delete disabled company-backends)))
    (add-to-list 'company-backends 'company-flyspell t)
    (define-global-minor-mode company-global-mode company-mode company-mode)
    (company-global-mode))
  (use-package company-c-headers
    :after company
    :config (add-to-list 'company-backends 'company-c-headers))
  (use-package gxref
    :config (add-to-list 'xref-backend-functions 'gxref-xref-backend))
  (use-package helm-gtags
    :delight
    :after helm
    :init (setq-default helm-gtags-auto-update t
                        helm-gtags-ignore-case t)
    :hook (company-mode . helm-gtags-mode))
  (use-package helm-company
    :after (helm company)
    :bind
    (:map company-mode-map
          ("<M-tab>" . helm-company)))
#+END_SRC

** Projectile

The project manager. Used in Eglot. #1 feature: find files in a project.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight
    :init
    (add-to-list 'project-find-functions 'my-projectile-project-find-function)
    (setq projectile-project-search-path
          (and (file-exists-p "~/Sources/") '("~/Sources/")))
    (projectile-add-known-project "~/dotfiles/")
    (setq projectile-globally-ignored-directories
          '(".git" ".hg" ".svn" "build" "target"))
    (projectile-mode)
    :bind-keymap ("C-c p" . projectile-command-map))
  (use-package helm-projectile
    :after (helm projectile)
    :init (helm-projectile-on))
#+END_SRC

** Eglot

The language server client. Includes a piece of glue for Projectile and
=lsp-remote= script, which see.

#+BEGIN_SRC emacs-lisp
  (defun my-projectile-project-find-function (dir)
    "Bridge between projectile and project.el.  Used by `eglot'.

  DIR so that Flymake stops complaining."
    (let ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (defconst level-up (file-name-as-directory ".."))

  (defvar eglot-custom-server-programs
    '((python-mode "python3" "-m" "pyls")
      (rust-mode "~/.cargo/bin/rls"))
    "Drop-in replacements for eglot's default server-program commands.")

  (use-package eglot
    :demand
    :commands (eglot eglot-ensure)
    :init
    (setq eglot-autoreconnect nil)
    (setq eglot-connect-timeout 25)
    (setq eglot-sync-connect t)
    :config
    ;; Replace eglot's unreasonable defaults.
    (pcase-dolist (`(,mode . ,command) eglot-custom-server-programs)
      (if-let ((entry (assoc mode eglot-server-programs)))
          (setf (cdr entry) command)
        (push (append (list mode) command) eglot-server-programs)))
    ;; Inject `lsp-remote' into all server commands.
    (dolist (cell eglot-server-programs)
      (when (listp (cdr cell))
        (unless (string-suffix-p "lsp-remote" (cadr cell))
          (push "~/.local/bin/lsp-remote" (cdr cell)))))
    (defun eglot--uri-to-path (uri)
      (expand-file-name
       (replace-regexp-in-string
        "^/tmp/"
        (concat (projectile-project-root) level-up)
        (url-filename (url-generic-parse-url uri)))))
    (defun eglot--path-to-uri (path)
      (concat "file:///tmp/"
              (file-relative-name path (concat (projectile-project-root path) level-up))))
    :hook ((python-mode js-mode typescript-mode sgml-mode xml-mode rust-mode) . eglot-ensure))
#+END_SRC

** Yasnippet

Epic snippets for epic people.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    :init
    (setq yas-triggers-in-field t)
    (setq yas-indent-line 'auto)
    :config
    ;; Tab is reserved in modal-mode.
    (dolist (key (list [(tab)] (kbd "TAB") (kbd "<tab>")))
      (define-key yas-minor-mode-map key nil))
    (yas-global-mode 1))
#+END_SRC

** Org-Mode

The beast born from Emacs. All this configuration is aimed at fixing
external program paths.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    (setq org-table-auto-blank-field nil)
    (setq org-confirm-babel-evaluate #'ignore)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((ditaa . t)))
    (setq org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((plantuml . t)))
    (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    ;; Tab is reserved.
    (dolist (key (list [(tab)] (kbd "TAB") (kbd "<tab>")))
      (define-key org-mode-map key nil))
    (setq org-latex-to-mathml-convert-command
          "latexmlmath \"%i\" --presentationmathml=%o"))

  (use-package org-preview-html)

  (use-package htmlize)
#+END_SRC

** Mini Modeline

Displays important information in the echo area. Very useful to
completely hide the modeline in EXWM buffers.

#+BEGIN_SRC emacs-lisp
  (use-package mini-modeline
    :delight
    :init
    (setq display-time-default-load-average nil)
    (setq display-time-day-and-date t)
    (display-time-mode 1)
    ;; Display the `display-time-string' entirely in mini-modeline.
    (setq global-mode-string (delq 'display-time-string global-mode-string))
    (setq mini-modeline-r-format '("%b | " display-time-string))
    ;; Disable strange visuals.
    (setq mini-modeline-display-gui-line nil)
    (setq mini-modeline-enhance-visual nil)
    (defun mini-modeline-mode--restore-modeline-hack (&rest _args)
      "Restore original modeline after it is removed by `mini-modeline-mode'."
      (when mini-modeline-mode
        (setq-default mode-line-format mini-modeline--orig-mode-line)))
    (advice-add #'mini-modeline-mode :after #'mini-modeline-mode--restore-modeline-hack)
    (mini-modeline-mode 1))
#+END_SRC

** Smartparens

Isn't it nice to have auto-closing parenthesis pairs?

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :delight
    :init (require 'smartparens-config)
    :hook ((prog-mode html-mode mhtml-mode smgl-mode) . smartparens-mode))
#+END_SRC

** Olivetti

A very nice package for centering text. Only used for plain-text
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :delight
    :demand
    :hook ((Info-mode text-mode org-mode markdown-mode) . olivetti-mode))
#+END_SRC

** Flymake

The only reason to use this over Flycheck is because Eglot doesn't
support it.

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :hook ((prog-mode sgml-mode xml-mode markdown-mode) . flymake-mode)
    :init
    (setq elisp-flymake-byte-compile-load-path
          (list-directories-recursively "~/.emacs.d/elpa/")))

  (use-package flyspell
    :delight
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))
#+END_SRC

** Small packages

Mostly major-modes for unsupported languages.

#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :delight
    :hook ((emacs-lisp-mode ielm-mode) . elisp-slime-nav-mode))

  (use-package dtrt-indent
    :delight
    :hook (prog-mode . dtrt-indent-mode))

  (use-package rust-mode
    :init
    (when-let* ((file "~/.cargo/bin/rustfmt")
                ((file-exists-p file)))
      (setq rust-rustfmt-bin file)
      (setq rust-format-on-save t)))

  (use-package web-mode
    :mode ("\\.html\\'" . web-mode))

  (use-package markdown-mode)

  (use-package typescript-mode)

  (use-package lua-mode)

  (use-package yaml-mode)
#+END_SRC

** Standard Packages

Various hooks and variables. Not much to say here.

#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :delight
    :hook ((prog-mode sgml-mode) . display-line-numbers-mode))

  (use-package xref
    :hook (emacs-lisp-mode . xref-etags-mode))

  (use-package whitespace
    :delight
    :init
    (setq whitespace-line-column 80)
    (setq whitespace-style '(face trailing tab-mark lines-tail))
    :hook ((prog-mode sgml-mode) . whitespace-mode))

  (use-package eldoc
    :delight
    :hook (prog-mode . eldoc-mode)
    :init (setq eldoc-idle-delay 0))

  (use-package emacs
    :delight (auto-revert-mode) (auto-fill-function)
    :mode (("\\.bash.*" . sh-mode)
           ("\\.gitignore" . prog-mode))
    :hook (text-mode . auto-fill-mode)
    :bind (("C-x C-b" . ibuffer)
           ("<backtab>" . ff-find-other-file))
    :init
    (setq-default fill-column 72)
    (setq confirm-kill-emacs #'yes-or-no-p)
    (setq confirm-kill-processes nil))
#+END_SRC

* Emux

A strange name for a small "package" which allows performing window
("pane") operations in a similar fashion to Tmux.

** Pane Operations

#+BEGIN_SRC emacs-lisp
(defun exchange-window (move-function &rest args)
  "Return an exchange buffers function calling MOVE-FUNCTION with optional ARGS."
  (lambda ()
    (interactive)
    (let ((old-buffer (current-buffer))
          (old-window (selected-window)))
      (funcall move-function args)
      (set-window-buffer old-window (current-buffer))
      (set-window-buffer (selected-window) old-buffer))))

#+END_SRC

** Keybindings

Emux's keybindings, in general, try to replicate those of Tmux. The main
difference is that Emacs is buffer-based, and the philosophy of "one
window — one shell" doesn't apply here; instead, =C-t t= is used to
start a separate login shell.

#+BEGIN_SRC emacs-lisp
  (defvar emux-map
    `(("C-t" . (("c" . emux-connect)
                ("t" . my-term)
                ("q" . force-kill-buffer)
                ("x" . delete-window)
                ("b" . switch-to-buffer)
                ("h" . windmove-left)
                ("j" . windmove-down)
                ("k" . windmove-up)
                ("l" . windmove-right)
                ("C-h" . ,(exchange-window #'windmove-left))
                ("C-j" . ,(exchange-window #'windmove-down))
                ("C-k" . ,(exchange-window #'windmove-up))
                ("C-l" . ,(exchange-window #'windmove-right))
                ("%" . split-window-right)
                ("\"" . split-window-below)
                ("," . previous-buffer)
                ("." . next-buffer)))))
#+END_SRC

** Shell

Here, my main in-Emacs terminal-solution is defined: =my-term=, a
wrapper around =ansi-term=. It is able to execute a command with
arguments, or start a login shell, which is, in fact, the main focus of
this function.

#+BEGIN_SRC emacs-lisp
(defun my-term (&optional command &rest args)
  "Start `ansi-term', executing COMMAND with ARGS.

If COMMAND is not set (e.g. interactive call), enter login shell.

COMMAND is spawned inside the project root,
if present, or in user's home directory."
  (interactive)
  (let* ((default-directory (or (projectile-project-root) (expand-file-name "~")))
         (command (if command
                      (concat command " " (string-join args " "))
                    (concat (getenv "SHELL") " -l")))
         (program (mktemp "my-term" command)))
    (chmod program #o744)
    (ansi-term program)))

(defun emux-ssh (hostname)
  "Start a `my-term' session which connects to HOSTNAME over SSH."
  (let ((connector
         (mktemp "emux-connector"
                 (format "ssh -tAY %s emacsclient -c" hostname))))
    (chmod connector #o744)
    (my-term connector)
    (emux-mode -1)))

(defun emux-connect ()
  "Choose a host to connect to, and connect to it via `emux-ssh'."
  (interactive)
  (when-let ((hosts '(("Tilde" . "nonk@tilde.as205315.net")
                      ("Music" . "music@185.222.117.80")))
             (hostname (helm (helm-build-sync-source "SSH Endpoints"
                               :candidates hosts))))
    (emux-ssh hostname)))

(defun force-kill-buffer ()
  "Kill this buffer even if it has a process running."
  (interactive)
  (let ((kill-buffer-query-functions
         (delq 'process-kill-buffer-query-function kill-buffer-query-functions)))
    (kill-this-buffer)))

(define-minor-mode emux-mode
  "Emux keybindings mode."
  :init-value t
  :lighter " ε"
  :keymap (bind (make-sparse-keymap) emux-map))
#+END_SRC

* Modes

#+BEGIN_SRC emacs-lisp
(defvar-local left-fringe-mode--is-managed nil
  "Non-nil if this buffer should have a fringe on the left.

`left-fringe-mode' isn't available in `left-fringe-mode--set-fringe', and this
variable serves as a workaround: it is set internally.")

(define-minor-mode left-fringe-mode
  "Toggle a small fringe on the left of the selected window.

Currently used by Flymake."
  :init-value nil
  (setq left-fringe-mode--is-managed left-fringe-mode)
  (left-fringe-mode--set-fringe)
  (add-hook 'window-configuration-change-hook #'left-fringe-mode--set-fringe))

(defun left-fringe-mode--set-fringe ()
  "Set/unset the left fringe on selected window."
  (set-window-fringes
   (selected-window)
   (if left-fringe-mode--is-managed
       (window-font-width) ; just enough for a '!'
     0)))

(add-hook 'flymake-mode-hook #'left-fringe-mode)

(defvar column-width-alist
  '(("COMMIT_EDITMSG$" . 72)
    ("^emacs-init.org$" . 80)
    (".org$" . 72)
    ("^\\*info\\*$" . 74)
    (".*" . 80)))

(define-minor-mode auto-fill-column-mode
  "Automatically adjust `fill-column' and others, according to the buffer name."
  :init-value nil
  (pcase-let* ((buffer-name (or buffer-file-name (buffer-name (current-buffer))))
               (entry (assoc buffer-name column-width-alist #'string-match))
               (`(,pattern . ,column) entry))
    (if auto-fill-column-mode
        (progn
          (setq fill-column column)
          (setq olivetti-body-width (+ column 2)))
      (set-to-default 'fill-column 'olivetti-body-width))))

(dolist (mode '(Info-mode-hook org-mode-hook text-mode-hook))
  (add-hook mode #'auto-fill-column-mode))
#+END_SRC

* Modal Editing

#+BEGIN_SRC emacs-lisp
  (defvar modal-bindings nil
    "A keys-alist describing all keybinding available in `normal' state.")

  (defvar modal-mode-specifics-alist nil
    "Keys-alists specific to certain major modes.

  CAR is the major mode symbol; CDR is a keys-alist.

  CDR is overlayed onto `modal-bindings', replacing keys already bound.")

  (defvar-local modal-state 'normal
    "Current state: either `normal' or `insert'.

  `modal-toggle-state' alters the keybindings according to this variable.")

  (defvar modal-mode-exit-key (kbd "TAB")
    "Key bound to `modal-exit'.

  It is set in the local keymap irreversibly.")

  ;;;; Basic functions.

  (defun modal--flip-state ()
    "Flip `modal-state' from `insert' to `normal' and vice versa.

  This _only_ sets `modal-state', without changing the keymap."
    (modal-toggle-state
     (if (eq modal-state 'normal)
         'insert
       'normal)))

  (defun modal--get-specifics ()
    "Return the relevant keys-alist(s) from `modal-mode-specifics-alist'.

  The return value is always a list."
    (let ((valid (list)))
      (pcase-dolist (`(,mode . ,specifics) modal-mode-specifics-alist valid)
        (when (derived-mode-p mode)
          (push specifics valid)))))

  (defun modal-toggle-state (&optional state)
    "Set `modal-state' and alter the local keymap.

  If STATE is non-nil, set `modal-state' to that; flip it otherwise."
    (if state
        (setq modal-state state)
      (modal--flip-state))
    (use-local-map
     (when (eq modal-state 'normal)
       (bind (make-sparse-keymap)
             (append-nested (list modal-bindings) (modal--get-specifics)))))
    (local-set-key modal-mode-exit-key #'modal-exit))

  (defun modal-insert (&optional arg)
    "Enter `insert' state from `normal'.

  When ARG is non-nil, ask for a string to repeat ARG times.  In this case, stay
  in `normal' state."
    (interactive "P")
    (modal-toggle-state 'insert)
    ;; Emulate Vi's insert mode with count.
    (when-let ((arg)
               (string (read-string (format "Repeat x%d: " arg)))
               (starting-size (buffer-size)))
      (dotimes (_ arg)
        (insert string))
      (unless (or (= (buffer-size) starting-size)
                  (string-match "^[[:space:]]+$" string))
        (delete-horizontal-space t))
      (modal-toggle-state 'normal)))

  (defun modal-exit ()
    "Return to `normal' state from `insert'.

  When already `normal', deactivate the mark and stop macro definition."
    (interactive)
    (when (eq modal-state 'normal)
      ;; Copied from `keyboard-quit':
      (deactivate-mark)
      (kmacro-keyboard-quit)
      (when defining-kbd-macro
        (force-mode-line-update t))
      (setq defining-kbd-macro nil))
    (modal-toggle-state 'normal))

  ;;;; Related modes.

  ;;;;; Modal.

  (define-minor-mode modal-mode
    "A minor mode that forces modal keybindings."
    :init-value nil
    :lighter " μ"
    :keymap (make-sparse-keymap)
    (if modal-mode
        (modal-toggle-state modal-state)
      (use-local-map nil)))

  ;;;;; Line-mark.

  (defvar line-mark-mode-map
    (let ((map (make-sparse-keymap)))
      (dolist (command '(next-line previous-line right-char
                                   left-char forward-char backward-char))
        (define-key map (vector 'remap command)
          (lambda ()
            (interactive)
            (call-interactively command)
            (line-mark--fix-point-and-mark))))
      map))

  (define-minor-mode line-mark-mode
    "Minor mode for selecting whole lines using `set-mark'."
    :init-value nil
    ;; Quite a bit of code was copied over from `rectangle-mark-mode'.
    (if (not line-mark-mode)
        (deactivate-mark)
      (add-hook 'deactivate-mark-hook (lambda () (line-mark-mode -1)))
      (unless (region-active-p)
        (push-mark (line-end-position) t t)
        (line-mark--fix-point-and-mark)
        (message "Mark set (line mode)"))))

  (defun line-mark--fix-point-and-mark ()
    "Make sure the mark and the point are in the right positions.

  There are two such 'positions': mark is in the beginning
  of a line, and the point is at the end and vice versa."
    (let* ((line (- (line-number-at-pos (mark)) (current-line)))
           (beginning (line-beginning-position line))
           (end (line-end-position line)))
      (cond
       ((> (point) beginning)
        (push-mark beginning t t)
        (goto-char (line-end-position)))
       ((< (point) end)
        (push-mark end t t)
        (goto-char (line-beginning-position))))))

  ;;;; Various commands.

  ;;;;; Context-sensitive (supplied prefix arg, or region is active).

  (defun eval-region-or-buffer ()
    "Evaluate region if it is active; evaluate whole buffer otherwise."
    (interactive)
    (if (use-region-p)
        (progn
          (eval-region (region-beginning) (region-end))
          (deactivate-mark))
      (eval-buffer)))

  (defun beginning-of-buffer-or-goto-line (&optional arg)
    "If ARG is supplied, go to that line.
  Go to the beginning of the buffer otherwise.

  Emulation of Vi's 'gg' command"
    (interactive "P")
    (if arg
        (goto-char (line-beginning-position arg))
      (goto-char (point-min))))

  (defun end-of-buffer-or-goto-line (&optional arg)
      "If ARG is supplied, go to that line.
  Go to the end of the buffer otherwise.

  Emulation of Vi's 'G' command"
    (interactive "P")
    (if arg
        (goto-char (line-beginning-position arg))
      (goto-char (point-max))))

  (defun kill-whole-line-or-region (&optional arg)
    "If region is active, kill it.  Otherwise, kill ARG (or the current) line(s)."
    (interactive "P")
    (if (use-region-p)
        (kill-region (region-beginning) (region-end))
      (kill-whole-line arg)))

  ;;;;; Combined.

  (defun open-line-and-insert ()
    "Call `open-line' and enter `insert' state."
    (interactive)
    (call-interactively #'open-line)
    (modal-insert))

  (defun newline-and-insert ()
    "Call `newline' and enter `insert' state."
    (interactive)
    (call-interactively #'newline)
    (modal-insert))

  (defun end-of-line-and-insert ()
    "Enter `insert' state after calling `end-of-line'."
    (interactive)
    (call-interactively #'end-of-line)
    (modal-insert))

  (defun beginning-of-line-and-insert ()
    "Enter `insert' state after calling `beginning-of-line'."
    (interactive)
    (call-interactively #'beginning-of-line)
    (modal-insert))

  ;;;;; Vi-like '/' search.

  (defvar-local modal-search-query nil)

  (defun modal-can-search-p ()
    "Return nil if user should be prompted for a search query."
    (and modal-search-query
         (not (string-empty-p modal-search-query))))

  (defun modal-search (&optional backwards)
    "Ask for a search query and move to the next match forwards.

  If BACKWARDS is non-nil, move to the next match backwards instead."
    (interactive "i")
    (when-let ((query (read-string "/")))
      (setq modal-search-query query)
      (if backwards
          (modal-search-prev)
        (modal-search-next))))

  (defun modal-search-next ()
    "Go to next match, prompting for a query if there is none."
    (interactive)
    (if (modal-can-search-p)
        (search-forward-regexp modal-search-query)
      (modal-search nil)))

  (defun modal-search-prev ()
    "Go to previous match, prompting for a query if there is none."
    (interactive)
    (if (modal-can-search-p)
        (search-backward-regexp modal-search-query)
      (modal-search t)))

  ;;;;; File operations.

  (defun rename-buffer-file (buffer new-name)
    "Rename BUFFER's file to NEW-NAME and re-open it."
    (interactive (list (current-buffer) (read-file-name "New name: ")))
    (let ((file (buffer-file-name buffer)))
      (unless file
        (user-error "Buffer is not assigned to a file"))
      (unless (file-exists-p file)
        (user-error "Buffer file doesn't exist.  Did you forget to save it?"))
      (rename-file file new-name t)
      (let ((kill-buffer-query-functions (list)))
        (kill-buffer buffer))
      (find-file new-name)))

  (defun delete-buffer-file (buffer)
    "Kill BUFFER (or the current buffer) after deleting its file."
    (interactive (list (current-buffer)))
    (let ((file (buffer-file-name buffer)))
      (unless file
        (user-error "Buffer is not assigned to a file"))
      (when (file-exists-p file)
        (delete-file file t))
      (kill-buffer buffer)))

  (defun modal--special-buffer-p ()
    "Return non-nil if the current buffer is considered 'special'."
    (or (derived-mode-p 'special-mode 'Info-mode)
        (string= (buffer-name) "*scratch*")))

  (defun modal-save-buffer (&optional arg)
    "Like `save-buffer', but doesn't save special buffers.

  Run with prefix arg ARG to force saving a buffer in this case.

  See `modal--special-buffer-p'."
    (interactive "P")
    (if (or (equal arg '(4)) (not (modal--special-buffer-p)))
        (save-buffer 0)
      (message (concat "Run with prefix arg to "
                       (propertize "really" 'face 'italic)
                       " save the buffer"))))

  ;;;;; Misc.

  (defun indent-right (count)
    "Indent COUNT level right."
    (interactive "p")
    (setq count (* count standard-indent))
    (if (use-region-p)
        (indent-rigidly (region-beginning) (region-end) count)
      (indent-rigidly (line-beginning-position) (line-end-position) count)))

  (defun indent-left (count)
    "Indent COUNT levels left."
    (interactive "p")
    (indent-right (- count)))

  (defun repeat-region (arg start end)
    "Repeat the text between START and END ARG times."
    (interactive "p\nr")
    (dotimes (_ arg)
      (insert (buffer-substring start end))))

  (defun modal-scroll-up (&optional arg)
    "Scroll up half a screenful ARG times."
    (interactive "p")
    (let ((lines (/ (window-text-height) 2)))
      (recenter (if (< arg 0) -1 0))
      (forward-line (if arg (* lines arg) lines))))

  (defun modal-scroll-down (&optional arg)
    "Scroll down half a screenful ARG times."
    (interactive "p")
    (modal-scroll-up (- arg)))

  (defun s/ (pattern new-name &optional search-fun)
    "Replace PATTERN with NEW-NAME, using SEARCH-FUN to match.

  SEARCH-FUN defaults to `re-search-forward', mostly for interactive calls.  It
  must always search forwards.

  Suitable for non-interactive use."
    (interactive "ss/\nss/%s/")
    (unless search-fun
      (setq search-fun #'re-search-forward))
    (let ((old-point (point)))
      (goto-char (point-min))
      (while (funcall search-fun pattern nil t)
        (replace-match new-name))
      (goto-char old-point)))

  (defun modal-rename-symbol ()
    "Rename symbol at point.

  If `eglot' is active, rename using the language server.
  Otherwise, replace text blindly."
    (interactive)
    (if-let ((symbol (symbol-at-point)))
        (if (eglot-managed-p)
            (call-interactively #'eglot-rename)
          (when-let* ((string (symbol-name symbol))
                      (prompt (format "Rename %s to: " string))
                      (new-name (read-string prompt)))
            (s/ string new-name #'search-forward)))
      (user-error "No symbol at point")))

  ;;;;; Movement-key combos.

  (defun replace-character-or-region ()
    "If region is set, kill it and enter `insert' state.

  Otherwise, prompt for a character and replace with it the one at point."
    (interactive)
    (if (use-region-p)
        (if (bound-and-true-p rectangle-mark-mode)
            (call-interactively #'string-rectangle)
          (call-interactively #'kill-region)
          (modal-insert))
      (when-let ((char (read-char "Replace with: ")))
        (replace-region-contents
         (point) (1+ (point))
         (lambda ()
           (char-to-string char))))))

  (defun move-and-kill (old-point)
    "Kill everything between OLD-POINT and point."
    (kill-region old-point (point)))

  (defun move-and-replace (old-point)
    "Kill everything between OLD-POINT and point, and enter `insert' state."
    (move-and-kill old-point)
    (modal-insert))

  (defun move-and-yank (old-point)
    "Save to kill ring everything between OLD-POINT and point."
    (kill-ring-save old-point (point)))

  (defun kill-ring-save-region-or-line ()
    "If region is active, save it to the kill ring.  Save current line otherwise."
    (interactive)
    (if (use-region-p)
        (call-interactively #'kill-ring-save)
      (kill-ring-save (line-beginning-position) (line-end-position))))

  ;;;; Key definitions.

  ;;;;; Internals.

  (defun modal--echo (format-string &rest args)
    "Display a message in echo area, without logging it to messages buffer.

  Used in `modal-combo' to display pressed keys.

  FORMAT-STRING and ARGS are used just like in `message'."
    (let ((message-log-max nil))
      (apply #'message format-string args)))

  (defun modal-combo (key move-fun &optional dwim-fun)
    "Return a keys-alist entry which expects a key combo.

  The CAR is KEY.  The CDR is a lambda which:
   ,* Calls DWIM-FUN if DWIM-FUN is supplied and KEY is pressed twice.
   ,* Calls MOVE-FUN if the point value has changed after a key combo.

  DWIM-FUN is a command.  MOVE-FUN is a command which
  takes one argument: the previous point value."
    (cons key
          (lambda ()
            (interactive)
            (let ((old-point (point))
                  (sequence
                   (progn
                     (modal--echo "%s-" key)
                     (read-key-sequence nil))))
              (modal--echo "%s-%s" key (key-description sequence))
              (when-let ((command (key-binding sequence)))
                (if (and dwim-fun (eq this-command command))
                    (call-interactively dwim-fun)
                  (call-interactively command)
                  (when (/= (point) old-point)
                    (funcall move-fun old-point))))))))

  ;;;;; Variables.

  (setq modal-bindings
        `(("h" . backward-char)
          ("j" . next-line)
          ("k" . previous-line)
          ("l" . forward-char)
          ("J" . scroll-up-line)
          ("K" . scroll-down-line)
          ("a" . beginning-of-line)
          ("e" . end-of-line)
          ("T" . back-to-indentation)
          ("H" . backward-sexp)
          ("L" . forward-sexp)
          ("w" . forward-word)
          ("b" . backward-word)
          ("(" . sp-backward-sexp)
          (")" . sp-forward-sexp)
          ("G" . end-of-buffer-or-goto-line)
          ("g" . (("g" . beginning-of-buffer-or-goto-line)
                  ("l" . avy-goto-line)
                  ("w" . avy-goto-word-1)
                  ("c" . avy-goto-char)))
          ("i" . modal-insert)
          ("A" . beginning-of-line-and-insert)
          ("E" . end-of-line-and-insert)
          ("o" . open-line-and-insert)
          ("m" . newline-and-insert)
          ("x" . delete-char)
          ("X" . delete-backward-char)
          ("f" . delete-indentation)
          ("s" . helm-swoop)
          ("S" . helm-multi-swoop-projectile)
          ("q" . kmacro-start-macro-or-insert-counter)
          ("Q" . kmacro-end-macro)
          ("@" . kmacro-end-and-call-macro)
          ("Z" . yas-expand)
          ("u" . undo)
          ("v" . set-mark-command)
          ("V" . line-mark-mode)
          ("C-v" . rectangle-mark-mode)
          ("D" . kill-line)
          ("p" . yank)
          (";" . comment-line)
          ("t" . indent-for-tab-command)
          ("F" . fill-paragraph)
          ("R" . repeat-region)
          ("c" . recenter-top-bottom)
          ("z" . cycle-spacing)
          ("/" . modal-search)
          ("n" . modal-search-next)
          ("N" . modal-search-prev)
          ("#" . insert-file)
          ("," . indent-left)
          ("." . indent-right)
          ("C-n" . modal-scroll-up)
          ("C-p" . modal-scroll-down)
          ("+" . text-scale-increase)
          ("-" . text-scale-decrease)
          ("0" . "C-0")
          ("1" . "C-1")
          ("2" . "C-2")
          ("3" . "C-3")
          ("4" . "C-4")
          ("5" . "C-5")
          ("6" . "C-6")
          ("7" . "C-7")
          ("8" . "C-8")
          ("9" . "C-9")
          ,(modal-combo "d" #'move-and-kill #'kill-whole-line-or-region)
          ,(modal-combo "r" #'move-and-replace #'replace-character-or-region)
          ,(modal-combo "y" #'move-and-yank #'kill-ring-save-region-or-line)
          (":" . (("w" . modal-save-buffer)
                  ("q" . kill-current-buffer)
                  ("s" . s/)
                  ("x" . helm-M-x)))
          ("SPC" . (("g" . magit-status)
                    ("u" . list-packages)
                    ("p" . ,projectile-command-map)
                    ("f" . helm-find-files)
                    ("b" . helm-buffers-list)
                    ("h" . ,help-map)
                    ("F" . eglot-code-actions)
                    ("r" . modal-rename-symbol)
                    ("d" . eldoc-doc-buffer)
                    ("w" . eww)
                    ("v" . reset-variable)
                    ("j" . flymake-goto-next-error)
                    ("k" . flymake-goto-prev-error)
                    ("e" . eval-region-or-buffer)
                    ("E" . eval-defun)
                    ("/" . dabbrev-expand)
                    ("o" . org-preview-html-mode)
                    ("x" . org-html-export-to-html)
                    ("X" . org-odt-export-to-odt)
                    ("'" . org-edit-src-exit)
                    ("C-r" . rename-buffer-file)
                    ("C-d" . delete-buffer-file)))))

  (setq modal-mode-specifics-alist
        '((eww-mode . (("H" . eww-back-url)
                       ("L" . eww-forward-url)
                       ("t" . eww)
                       ("z" . eww-copy-page-url)
                       ("<M-return>" . eww-open-in-new-buffer)))
          (special-mode . (("q" . quit-window)))
          (help-mode . (("<" . help-go-back)
                        (">" . help-go-forward)
                        ("RET" . help-follow)))
          (Info-mode . (("q" . quit-window)
                        ("H" . Info-prev)
                        ("L" . Info-next)
                        ("<" . Info-history-back)
                        (">" . Info-history-forward)
                        ("^" . Info-up)
                        ("RET" . Info-follow-nearest-node)))
          (org-mode . (("f" . org-cycle)
                       ("SPC" . (("SPC" . org-edit-special)
                                 ("j" . org-next-visible-heading)
                                 ("k" . org-previous-visible-heading)
                                 ("J" . org-forward-heading-same-level)
                                 ("K" . org-backward-heading-same-level)))))))

  ;;;; Hooks.

  (dolist (mode '(prog text conf help apropos Info eww picture))
    (add-hook (s-concat mode "-mode-hook") #'modal-mode))
#+END_SRC

* EXWM Configuration

#+BEGIN_SRC emacs-lisp
  ;;;; Keybindings.

  (defun exec ()
    "Execute a command asynchronously."
    (interactive)
    (sh (read-shell-command "$ ") 0))

  (defun exec-buf ()
    "Execute a command similarly to `exec', showing its output in a buffer."
    (interactive)
    (with-output-to-temp-buffer "*Command output*"
      (sh (read-shell-command "$ ") standard-output)))

  (defun sh-binding (command)
    "Return a lambda running `sh' with COMMAND.  Useful for setting up keys."
    `(lambda () (interactive) (sh ,command 0)))

  (defun mpd-binding (command &rest args)
    "Like `sh-binding', but call `mpd-control' with COMMAND and ARGS."
    (sh-binding (format "mpd-control %s %s" command (string-join args " "))))

  (defun download-track (url)
    "Download a music track from URL, using `mpd-control'."
    (interactive "sURL: ")
    ;; Quote the URL in case it contains weird characters.
    (funcall (mpd-binding "download" (format "'%s'" url))))

  (defun quick ()
    "Launch a program or utility from a `helm' listing."
    (interactive)
    (when-let*
        ((quick '(("Browser"    . "qutebrowser --no-err-windows")
                  ("Discord"    . "discord")
                  ("Parsec"     . "parsecd app_daemon=1")
                  ("Moonlight"  . "moonlight")
                  ("Steam"      . "steam")
                  ("Doomseeker" . "doomseeker")
                  ("Torrent"    . "transmission-gtk")
                  ("PA Volume"  . "pavucontrol")
                  ("Zoom"       . "zoom")
                  ("Aria"       . "Aria")))
         (utils '(("Restart fluidsynth" . "systemctl --user restart fluidsynth")
                  ("Restart mpd" . "systemctl --user restart mpd && mpd-control play")
                  ("SSH proxy to tilde" . "ssh -ND 9050 nonk@tilde.as205315.net")
                  ("Kill all SSH connections" . "pkill ssh")))
         (command (helm
                   :prompt "Launch: "
                   :buffer "*Program selection*"
                   :sources
                   (vector
                    (helm-build-sync-source "Quick launch"
                      :candidates quick)
                    (helm-build-sync-source "Utilities"
                      :candidates utils)))))
      (sh command 0)))

  ;;;; Window layouts.

  (defvar window-layout-defs
    '(("d" . ())
      ("b" . ())
      ("c" . (:right my-term :below my-term))
      ("t" . (my-term))
      ("i" . ())
      ("1" . ())
      ("2" . ())
      ("3" . ()))
    "Description of window layouts created on EXWM startup.")

  (defvar layout-mappings '())

  (defun generate-layouts ()
    "Generate EXWM frames from `window-layout-defs'."
    (dolist (def window-layout-defs)
      (set-buffer "*scratch*") ; *scratch* is the starting buffer
      (let ((workspace (exwm-workspace-add)))
        (dolist (token (cdr def))
          (cl-typecase token
            (keyword        ; :right and :below just split the current window
             (select-window ; this makes the split window current
              (cond
               ((eq token :right)
                (split-window-right))
               ((eq token :below)
                (split-window-below))
               (t
                (user-error "Unrecognized token: %s" token)))))
            (t
             (funcall token)))) ; call symbols and lambdas (untested)
        ;; Save the frame for use in `select-layout'.
        (add-to-list 'layout-mappings (cons (car def) workspace)))))

  (defun select-layout ()
    "Ask user to select a layout from `layout-mappings'."
    (interactive)
    (unless layout-mappings ; create the frames on first call
      (generate-layouts))
    (if-let* ((letter (read-key "Layout: "))
              (letter (key-description (list letter))) ; strings are used as keys
              (mapping (assoc letter layout-mappings))
              (workspace (cdr mapping))
              ;; Bail out if the frame is dead.
              (workspace (when (frame-live-p workspace) workspace)))
        (exwm-workspace-switch workspace)
      (user-error "Not a layout")))

  (defun copy-10 ()
    "Enter a Unicode character's base-10 value and copy it to clipboard."
    (interactive)
    (with-temp-buffer
      (let ((read-quoted-char-radix 10))
        (quoted-insert 1)
        (clipboard-kill-ring-save (point-min) (point-max)))))

  (defun copy-unicode ()
    "Search for a Unicode character and copy it to clipboard."
    (interactive)
    (with-temp-buffer
      (call-interactively #'insert-char)
      (clipboard-kill-ring-save (point-min) (point-max))))

  ;;;; `use-package' declaration.

  (use-package exwm
    :init
    ;; Easy window-switching with s-b.
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)
    ;; C-c is a prefix key; send ^C with C-c C-c.
    (setq exwm-input-simulation-keys '(([?\C-c ?\C-c] . ?\C-c)))
    (setq exwm-input-global-keys
          (mapcar
           (lambda (binding)
             (cons (kbd (car binding)) (cdr binding)))
           `(("s-h" . windmove-left) ; basic movement keys
             ("s-j" . windmove-down)
             ("s-k" . windmove-up)
             ("s-l" . windmove-right)
             ("C-s-h" . ,(exchange-window #'windmove-left)) ; swap buffers
             ("C-s-j" . ,(exchange-window #'windmove-down))
             ("C-s-k" . ,(exchange-window #'windmove-up))
             ("C-s-l" . ,(exchange-window #'windmove-right))
             ("M-s-h" . shrink-window-horizontally) ; weird resize
             ("M-s-j" . enlarge-window)
             ("M-s-k" . shrink-window)
             ("M-s-l" . enlarge-window-horizontally)
             ("s-n" . split-window-below) ; obviously, window-splits
             ("s-m" . split-window-right)
             ("s-w" . delete-window)     ; kill a window (buffer is left behind)
             ("s-q" . force-kill-buffer) ; kill a buffer
             ("s-b" . switch-to-buffer)  ; select a buffer
             ("s-f" . exwm-layout-toggle-fullscreen) ; window modes
             ("s-r" . exwm-floating-toggle-floating)
             ("s-g" . exwm-input-toggle-keyboard) ; char and line mode switch
             ("s-i" . load-init)     ; reload init file
             ("s-v" . select-layout) ; change workspace
             ("s-'" . copy-unicode)  ; weird stuff
             ("s-0" . copy-10)
             ("s-s" . exwm-input-send-next-key)
             ("s-e" . exec)
             ("s-E" . exec-buf)
             ("<s-return>" . my-term) ; common programs
             ("<print>" . ,(sh-binding "screenshot"))
             ("s-d" . quick) ; dmenu-like prompt
             ("s-p" . ,(mpd-binding "select")) ; music
             ("s-," . ,(mpd-binding "prev"))
             ("s-." . ,(mpd-binding "next"))
             ("s-o" . ,(mpd-binding "toggle"))
             ("s-;" . ,(mpd-binding "clear"))
             ("s-[" . ,(mpd-binding "status"))
             ("s-]" . ,(mpd-binding "single"))
             ("s-ä" . ,(mpd-binding "seek -8"))
             ("s-$" . ,(mpd-binding "seek +8"))))))

  ;;;; EXWM magic.

  (defun exwm-update-class-actions ()
    (unless exwm-title
      (exwm-workspace-rename-buffer exwm-class-name)))
  (add-hook 'exwm-update-class-hook #'exwm-update-class-actions)

  (defun exwm-update-title-actions ()
    (exwm-workspace-rename-buffer exwm-title))
  (add-hook 'exwm-update-title-hook #'exwm-update-title-actions)

  (defun exwm-disable-modeline ()
    "Delegate modeline display to `mini-modeline-mode'."
    (setq mode-line-format nil))
  (add-hook 'exwm-manage-finish-hook #'exwm-disable-modeline)

  (defvar exwm-enabled nil
    "Non-nil if `start-exwm' was run.")

  (defun exwm-update-input ()
    "Re-bind EXWM keys after `exwm-input-global-keys' update."
    (dolist (binding exwm-input-global-keys)
      (exwm-input--set-key (car binding) (cdr binding))))

  (defun exwm-init-actions ()
    "Hook run when the EXWM session is initialized."
    (use-package humanoid-themes)
    (load-theme 'humanoid-dark t)
    (set-frame-font "Hack 10" nil t)
    (unbind global-map "C-z") ; can't hide EXWM frames
    (setq exwm-enabled t))
  (add-hook 'exwm-init-hook #'exwm-init-actions)

  (add-hook 'exwm-exit-hook (lambda () (setq exwm-enabled nil)))

  (defun start-exwm ()
    "Start EXWM session.  Used in .xinitrc."
    (exwm-enable)
    (scroll-bar-mode 0)
    (fringe-mode 0))

  ;; If EXWM is still running, re-bind the keys.
  (when exwm-enabled
    (exwm-update-input))
#+END_SRC

* Miscellaneous

#+BEGIN_SRC emacs-lisp
  (c-add-style "nonk123"
               '("java"
                 (c-basic-offset . 4)
                 (c-offsets-alist ((access-label . /)
                                   (case-label . +)))))

  (setq c-default-style
        '((java-mode . "java")
          (awk-mode . "awk")
          (other . "nonk123")))

  (setq inhibit-startup-message t)

  (setq-default
   indent-tabs-mode nil
   tab-stop-list nil
   epa-pinentry-mode 'loopback
   vc-follow-symlinks t
   major-mode #'prog-mode)

  (menu-bar-mode 0)
  (tool-bar-mode 0)

  (blink-cursor-mode 0)

  (delete-selection-mode 1)

  (show-paren-mode 1)

  (column-number-mode 1)
#+END_SRC
