#+TITLE: nonk123's GNU/Emacs configuration
#+AUTHOR: nonk123

* Initialization

Due to lambda abuse, lexical binding is a requirement for this
configuration to work. As such, =modal-combo= and similar functions
break when a lexical argument (i.e. =key=) is not available within the
closure.

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

* Utilities

Various utilities need to be initialized before loading the necessary
packages.

** Keymap Functions

Out of keymap utilities, =bind= is, by far, the most sophisticated. A
big part of its complexity comes from multiple types of bindings:
commands, key aliases, and other keymaps.

#+BEGIN_SRC emacs-lisp
(defun unbind (keymap &rest keys)
  "Unbind KEYS from a KEYMAP."
  (dolist (key keys)
    (define-key keymap (kbd key) nil)))

(defun bind (keymap keys-alist)
  "Bind keys from KEYS-ALIST onto KEYMAP and return it.

CAR is a key description.  CDR is one of the following:
 * Command name as a symbol, or a lambda (CAR is bound to CDR).
 * A key description (CAR is an alias to CDR).
 * Another keys-alist (CAR is a prefix key)."
  (pcase-dolist (`(,key . ,def) keys-alist keymap)
    (setq key (kbd key))
    (cl-typecase def
      (string ; key description
       (define-key keymap key (kbd def)))
      ((or symbol function keymap) ; command
       (define-key keymap key def))
      (t ; keys-alist (a prefix)
       (let* ((prefix (lookup-key keymap key))
              (prefix (or (and (keymapp prefix) prefix)
                          (make-sparse-keymap))))
         (define-key keymap key (bind prefix def)))))))
#+END_SRC

** Shell

Not much explanation is needed: =sh= runs shell commands. Interestingly
enough, it starts a /login/ shell in order to execute =~/.bashrc=.

#+BEGIN_SRC emacs-lisp
  (defun sh (cmd &optional destination pwd)
    "Run CMD using the default shell.

  DESTINATION is passed to `call-process'.

  If PWD is specified, use that as the `default-directory', instead of \"~\"."
    (interactive)
    (let ((default-directory (or pwd "~")))
      (call-process (getenv "SHELL") nil destination nil "-l" "-c" cmd)))
#+END_SRC

** Prompt

=prompt= is used as an Elisp backend for the shell script with the same
name.

In short, =prompt= displays a =helm= listing with candidates from stdin,
much like suckless's =dmenu=.

#+BEGIN_SRC emacs-lisp
  (defun prompt--action (_candidates)
    "Output marked candidates, each on its own line.

  Used internally in function `prompt'."
    (with-output-to-string
      (mapc #'princ (helm-marked-candidates))
      (princ "\n")))

  (defun prompt (msg file)
    "Show a prompt, using candidates from FILE and MSG as the prompt message."
    (interactive)
    (helm :prompt msg
          :candidate-number-limit 250
          :buffer (format "*%s*" msg)
          :sources (helm-build-sync-source msg
                     :action #'prompt--action
                     :candidates
                     (if (file-exists-p file)
                         (with-temp-buffer
                           (insert-file-contents file)
                           ;; Each candidate on a separate line.
                           (split-string (buffer-string) "\n" t))
                       (error (format "File doesn't exist: %s" file))))))
#+END_SRC

** Miscellaneous

These are various utility functions used in other parts of the file.

#+BEGIN_SRC emacs-lisp
  (defun symbol-to-string (x)
    "Convert X (a symbol) to string unless it already is a string."
    (if (stringp x)
        x
      (symbol-name x)))

  (defun s-concat (&rest symbols)
    "Concatenate SYMBOLS into one big symbol.

  Each entry in SYMBOLS is either a string or a symbol."
    (intern (string-join (mapcar #'symbol-to-string symbols) "")))

  (defun list-directories-recursively (start)
    "List all directories in directory START recursively."
    (seq-filter #'file-directory-p (directory-files-recursively start ".+" t)))

  (defun append-nested (&rest sequences)
    "Join the nested lists inside each element of SEQUENCES, akin to `append'."
    (let ((result (list)))
      (dolist (sequence sequences (reverse result))
        (dolist (nested sequence)
          (dolist (elt nested)
            (push elt result))))))

  (defun mktemp (filename &optional contents)
    "Create FILENAME in temporary directory, suffixed with random garbage.

  Insert CONTENTS if non-nil.

  Return the created file's name like `make-temp-file' (which see)."
    (make-temp-file filename nil nil contents))

  (defun set-to-default (&rest variables)
    "Reset VARIABLES to their default values."
    (dolist (variable variables)
      (set variable (default-value variable))))

  (defun reset-variable ()
    "Interactive version of `set-to-default' (which see).

  Prompt the user to select a buffer-local variable, and reset its value."
    (interactive)
    (when-let* ((symbol (completing-read
                         "Reset value of: "
                         ;; Taken straight from help-fns.el:
                         #'help--symbol-completion-table
                         (lambda (var)
                           (and (or (get var 'variable-documentation)
                                    (and (boundp var) (not (keywordp var))))
                                ;; Slight modification: `default-value' works
                                ;; on buffer-local variables only.
                                (local-variable-p var))))))
      (set-to-default (intern symbol))))
#+END_SRC

* Packages

All external packages are loaded here with =use-package=. Details of its
automatic installation are described in [[./init.el][init.el]].

** Delight

Delight is a package for "de-lighting" modes; that is, modifying or
hiding their lighter, which is very useful for uncluttering the
modeline.

There is nothing special about loading =delight= as it's primarily seen
in =use-package= declarations.

#+BEGIN_SRC emacs-lisp
  (use-package delight)
#+END_SRC

** Helm

Helm is a great completion framework. It allows choosing candidates in a
separate buffer using =C-p= & =C-n= selection and regexp matching.

Many commands are replaced with Helm equivalents, which can also be seen
in =:bind= declaration. This package comes with many supplements; some
are loaded later in the file.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand
    :delight (helm-mode) (helm-ff-cache-mode)
    :init (require 'helm-config)
    :config (helm-mode 1)
    :bind (("M-x"     . helm-M-x)
           ("C-x b"   . helm-buffers-list)
           ("C-c M-x" . execute-extended-command)
           ("C-x C-f" . helm-find-files)))
  (use-package helm-swoop
    :after (helm projectile))
  (use-package helm-ag
    :after helm)
  (use-package helm-xref
    :after helm)
#+END_SRC

** Avy

Avy is a package I rarely use. It allows jumping to any place in the
buffer in only a few keypresses.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :init (setq avy-keys '(?h ?j ?k ?l ?a ?s ?d ?f)))
#+END_SRC

** Magit

Magit is a Git portmanteau, which I only use for improved diff, rebase,
commit message, etc. editing.

No special configuration is required.

#+BEGIN_SRC emacs-lisp
  (use-package magit)
#+END_SRC

** Company

Company ("complete anything") is a text completion framework. In this
configuration, it's mainly used as the connector between different
completion engines available.

Also included in this section are global tags packages: =gxref= and
=helm-gtags=. Completion candidate selection is done via =helm-company=.

=:config= section defines an homebrewn =company= backend:
=company-flyspell=. Though rarely used, it served as a nice way of
practicing Elisp.

Several default backends have been disabled for either being nonsensical
(=company-dabbrev=), or relying on external software (=company-clang=).

#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :init (setq company-idle-delay nil)
    :config
    (defun company-flyspell (command &optional value &rest _args)
      (pcase command
        ('prefix (when-let ((word (car (ispell-get-word nil)))) word))
        ('candidates
         (ispell-send-string "%\n")
         (ispell-send-string (concat "^" value "\n"))
         (while (progn
                  (ispell-accept-output)
                  (not (string= "" (car ispell-filter)))))
         (setq ispell-filter (cdr ispell-filter))
         (when (and ispell-filter (listp ispell-filter))
           (let ((result (ispell-parse-output (car ispell-filter))))
             (if (listp result)
                 (append (caddr result) (caddr result))
               '()))))))
    (dolist (disabled '(company-eclim company-clang company-xcode company-dabbrev))
      (setq company-backends (delete disabled company-backends)))
    (add-to-list 'company-backends 'company-flyspell t)
    (define-global-minor-mode company-global-mode company-mode company-mode)
    (company-global-mode))
  (use-package company-c-headers
    :after company
    :config (add-to-list 'company-backends 'company-c-headers))
  (use-package gxref
    :config (add-to-list 'xref-backend-functions 'gxref-xref-backend))
  (use-package helm-gtags
    :delight
    :after helm
    :init (setq-default helm-gtags-auto-update t
                        helm-gtags-ignore-case t)
    :hook (company-mode . helm-gtags-mode))
  (use-package helm-company
    :after (helm company)
    :bind
    (:map company-mode-map
          ("<M-tab>" . helm-company)))
#+END_SRC

** Projectile



#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight
    :init
    (add-to-list 'project-find-functions 'my-projectile-project-find-function)
    (setq projectile-project-search-path
          (and (file-exists-p "~/Sources/") '("~/Sources/")))
    (projectile-add-known-project "~/dotfiles/")
    (setq projectile-globally-ignored-directories
          '(".git" ".hg" ".svn" "build" "target"))
    (projectile-mode)
    :bind-keymap ("C-c p" . projectile-command-map))
  (use-package helm-projectile
    :after (helm projectile)
    :init (helm-projectile-on))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-projectile-project-find-function (dir)
    "Bridge between projectile and project.el.  Used by `eglot'.

  DIR so that Flymake stops complaining."
    (let ((root (projectile-project-root dir)))
      (and root (cons 'transient root))))

  (defconst level-up (file-name-as-directory ".."))

  (defvar eglot-custom-server-programs
    '((python-mode "python3" "-m" "pyls")
      (rust-mode "~/.cargo/bin/rls"))
    "Drop-in replacements for eglot's default server-program commands.")

  (use-package eglot
    :demand
    :commands (eglot eglot-ensure)
    :init
    (setq eglot-autoreconnect nil)
    (setq eglot-connect-timeout 25)
    (setq eglot-sync-connect t)
    :config
    ;; Replace eglot's unreasonable defaults.
    (pcase-dolist (`(,mode . ,command) eglot-custom-server-programs)
      (if-let ((entry (assoc mode eglot-server-programs)))
          (setf (cdr entry) command)
        (push (append (list mode) command) eglot-server-programs)))
    ;; Inject `lsp-remote' into all server commands.
    (dolist (cell eglot-server-programs)
      (when (listp (cdr cell))
        (unless (string-suffix-p "lsp-remote" (cadr cell))
          (push "~/.local/bin/lsp-remote" (cdr cell)))))
    (defun eglot--uri-to-path (uri)
      (expand-file-name
       (replace-regexp-in-string
        "^/tmp/"
        (concat (projectile-project-root) level-up)
        (url-filename (url-generic-parse-url uri)))))
    (defun eglot--path-to-uri (path)
      (concat "file:///tmp/"
              (file-relative-name path (concat (projectile-project-root path) level-up))))
    :hook ((python-mode js-mode typescript-mode sgml-mode xml-mode rust-mode) . eglot-ensure))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    :init
    (setq yas-triggers-in-field t)
    (setq yas-indent-line 'auto)
    :config
    (define-key yas-minor-mode-map [(tab)] nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (yas-global-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :delight
    :init
    (require 'smartparens-config)
    (setq sp-highlight-pair-overlay nil)
    :hook ((prog-mode html-mode mhtml-mode smgl-mode) . smartparens-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :delight
    :demand
    :hook ((Info-mode text-mode org-mode markdown-mode) . olivetti-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org
    :init
    (setq org-table-auto-blank-field nil)
    (setq org-entities-user
          '(("Emacr" "\\bar{E}" nil "&Emacr;" "E" "Ē" "Ē")
            ("emacr" "\\bar{e}" nil "&emacr;" "e" "ē" "ē")
            ("Ebreve" "\\u{E}" nil "&#276;" "E" "Ĕ" "Ĕ")
            ("ebreve" "\\u{e}" nil "&#277;" "e" "ĕ" "ĕ")
            ("Omacr" "\\bar{O}" nil "&Omacr;" "O" "Ō" "Ō")
            ("omacr" "\\bar{o}" nil "&omacr;" "o" "ō" "ō")
            ("Lacute" "\\'{L}" nil "&Lacute;" "L" "Ĺ" "Ĺ")
            ("lacute" "\\'{l}" nil "&lacute;" "l" "ĺ" "ĺ")
            ("Kacute" "\\'{K}" nil "&#7728;" "K" "Ḱ" "Ḱ")
            ("kacute" "\\'{k}" nil "&#7729;" "k" "ḱ" "ḱ")
            ("Kw" "K^{w}" nil "K&#695;" "Kw" "Kʷ" "Kʷ")
            ("kw" "k^{w}" nil "k&#695;" "kw" "kʷ" "kʷ")
            ("Hi" "H_{1}" nil "H&#8321;" "H1" "H₁" "H₁")
            ("hi" "h_{1}" nil "h&#8321;" "h1" "h₁" "h₁")
            ("hii" "h_{2}" nil "h&#8322;" "h2" "h₂" "h₂")
            ("hiii" "h_{3}" nil "h&#8323;" "h3" "h₃" "h₃")
            ("cbr" "_{o}" nil "&#805;" "." "̥" "̥")))
    :config
    (setq org-confirm-babel-evaluate #'ignore)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((ditaa . t)))
    (defvar org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((plantuml . t)))
    (defvar org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    (dolist (key (list [(tab)] (kbd "TAB") (kbd "<tab>")))
      (define-key org-mode-map key nil)))

  (use-package org-preview-html)

  (use-package htmlize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package elisp-slime-nav
    :delight
    :hook ((emacs-lisp-mode ielm-mode) . elisp-slime-nav-mode))

  (use-package dtrt-indent
    :delight
    :hook (prog-mode . dtrt-indent-mode))

  (use-package rust-mode)

  (use-package web-mode
    :mode ("\\.html\\'" . web-mode))

  (use-package markdown-mode)

  (use-package typescript-mode)

  (use-package lua-mode)

  (use-package yaml-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :hook ((prog-mode sgml-mode xml-mode markdown-mode) . flymake-mode)
    :init
    (setq elisp-flymake-byte-compile-load-path
          (list-directories-recursively "~/.emacs.d/elpa/")))

  (use-package flyspell
    :delight
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package display-line-numbers
    :delight
    :hook ((prog-mode sgml-mode) . display-line-numbers-mode))

  (use-package xref
    :hook (emacs-lisp-mode . xref-etags-mode))

  (use-package whitespace
    :delight
    :init
    (setq whitespace-line-column 80)
    (setq whitespace-style '(face trailing tab-mark lines-tail))
    :hook ((prog-mode sgml-mode) . whitespace-mode))

  (use-package eldoc
    :delight
    :hook (prog-mode . eldoc-mode)
    :init (setq eldoc-idle-delay 0))

  (use-package emacs
    :delight (auto-revert-mode) (auto-fill-function)
    :mode (("\\.bash.*" . sh-mode)
           ("\\.gitignore" . prog-mode))
    :hook (text-mode . auto-fill-mode)
    :bind (("C-x C-b" . ibuffer)
           ("<backtab>" . ff-find-other-file))
    :init
    (setq-default fill-column 72)
    (setq confirm-kill-emacs #'yes-or-no-p)
    (setq confirm-kill-processes nil))
#+END_SRC

* Emux

A strange name for a small "package" which allows performing window
("pane") operations in a similar fashion to Tmux.

** Pane Operations

#+BEGIN_SRC emacs-lisp
(defun exchange-window (move-function &rest args)
  "Return an exchange buffers function calling MOVE-FUNCTION with optional ARGS."
  (lambda ()
    (interactive)
    (let ((old-buffer (current-buffer))
          (old-window (selected-window)))
      (funcall move-function args)
      (set-window-buffer old-window (current-buffer))
      (set-window-buffer (selected-window) old-buffer))))

#+END_SRC

** Keybindings

Emux's keybindings, in general, try to replicate those of Tmux. The main
difference is that Emacs is buffer-based, and the philosophy of "one
window — one shell" doesn't apply here; instead, =C-t t= is used to
start a separate login shell.

#+BEGIN_SRC emacs-lisp
  (defvar emux-map
    `(("C-t" . (("c" . emux-connect)
                ("t" . my-term)
                ("q" . force-kill-buffer)
                ("x" . delete-window)
                ("b" . switch-to-buffer)
                ("h" . windmove-left)
                ("j" . windmove-down)
                ("k" . windmove-up)
                ("l" . windmove-right)
                ("C-h" . ,(exchange-window #'windmove-left))
                ("C-j" . ,(exchange-window #'windmove-down))
                ("C-k" . ,(exchange-window #'windmove-up))
                ("C-l" . ,(exchange-window #'windmove-right))
                ("%" . split-window-right)
                ("\"" . split-window-below)
                ("," . previous-buffer)
                ("." . next-buffer)))))
#+END_SRC

** Shell

Here, my main in-Emacs terminal-solution is defined: =my-term=, a
wrapper around =ansi-term=. It is able to execute a command with
arguments, or start a login shell, which is, in fact, the main focus of
this function.

#+BEGIN_SRC emacs-lisp
(defun my-term (&optional command &rest args)
  "Start `ansi-term', executing COMMAND with ARGS.

If COMMAND is not set (e.g. interactive call), enter login shell.

COMMAND is spawned inside the project root,
if present, or in user's home directory."
  (interactive)
  (let* ((default-directory (or (projectile-project-root) (expand-file-name "~")))
         (command (if command
                      (concat command " " (string-join args " "))
                    (concat (getenv "SHELL") " -l")))
         (program (mktemp "my-term" command)))
    (chmod program #o744)
    (ansi-term program)))

(defun emux-ssh (hostname)
  "Start a `my-term' session which connects to HOSTNAME over SSH."
  (let ((connector
         (mktemp "emux-connector"
                 (format "ssh -tAY %s emacsclient -c" hostname))))
    (chmod connector #o744)
    (my-term connector)
    (emux-mode -1)))

(defun emux-connect ()
  "Choose a host to connect to, and connect to it via `emux-ssh'."
  (interactive)
  (when-let ((hosts '(("Tilde" . "nonk@tilde.as205315.net")
                      ("Music" . "music@185.222.117.80")))
             (hostname (helm (helm-build-sync-source "SSH Endpoints"
                               :candidates hosts))))
    (emux-ssh hostname)))

(defun force-kill-buffer ()
  "Kill this buffer even if it has a process running."
  (interactive)
  (let ((kill-buffer-query-functions
         (delq 'process-kill-buffer-query-function kill-buffer-query-functions)))
    (kill-this-buffer)))

(define-minor-mode emux-mode
  "Emux keybindings mode."
  :init-value t
  :lighter " ε"
  :keymap (bind (make-sparse-keymap) emux-map))
#+END_SRC

* Modes

#+BEGIN_SRC emacs-lisp
(defvar-local left-fringe-mode--is-managed nil
  "Non-nil if this buffer should have a fringe on the left.

`left-fringe-mode' isn't available in `left-fringe-mode--set-fringe', and this
variable serves as a workaround: it is set internally.")

(define-minor-mode left-fringe-mode
  "Toggle a small fringe on the left of the selected window.

Currently used by Flymake."
  :init-value nil
  (setq left-fringe-mode--is-managed left-fringe-mode)
  (left-fringe-mode--set-fringe)
  (add-hook 'window-configuration-change-hook #'left-fringe-mode--set-fringe))

(defun left-fringe-mode--set-fringe ()
  "Set/unset the left fringe on selected window."
  (set-window-fringes
   (selected-window)
   (if left-fringe-mode--is-managed
       (window-font-width) ; just enough for a '!'
     0)))

(add-hook 'flymake-mode-hook #'left-fringe-mode)

(defvar column-width-alist
  '(("COMMIT_EDITMSG$" . 72)
    ("^emacs-init.org$" . 80)
    (".org$" . 72)
    ("^\\*info\\*$" . 74)
    (".*" . 80)))

(define-minor-mode auto-fill-column-mode
  "Automatically adjust `fill-column' and others, according to the buffer name."
  :init-value nil
  (pcase-let* ((buffer-name (or buffer-file-name (buffer-name (current-buffer))))
               (entry (assoc buffer-name column-width-alist #'string-match))
               (`(,pattern . ,column) entry))
    (if auto-fill-column-mode
        (progn
          (setq fill-column column)
          (setq olivetti-body-width (+ column 2)))
      (set-to-default 'fill-column 'olivetti-body-width))))

(dolist (mode '(Info-mode-hook org-mode-hook text-mode-hook))
  (add-hook mode #'auto-fill-column-mode))
#+END_SRC

* Modal Editing

#+BEGIN_SRC emacs-lisp
  (defvar modal-bindings nil
    "A keys-alist describing all keybinding available in `normal' state.")

  (defvar modal-mode-specifics-alist nil
    "Keys-alists specific to certain major modes.

  CAR is the major mode symbol; CDR is a keys-alist.

  CDR is overlayed onto `modal-bindings', replacing keys already bound.")

  (defvar-local modal-state 'normal
    "Current state: either `normal' or `insert'.

  `modal-toggle-state' alters the keybindings according to this variable.")

  (defvar modal-mode-exit-key (kbd "TAB")
    "Key bound to `modal-exit'.

  It is set in the local keymap irreversibly.")

  ;;;; Basic functions.

  (defun modal--flip-state ()
    "Flip `modal-state' from `insert' to `normal' and vice versa.

  This _only_ sets `modal-state', without changing the keymap."
    (modal-toggle-state
     (if (eq modal-state 'normal)
         'insert
       'normal)))

  (defun modal--get-specifics ()
    "Return the relevant keys-alist(s) from `modal-mode-specifics-alist'.

  The return value is always a list."
    (let ((valid (list)))
      (pcase-dolist (`(,mode . ,specifics) modal-mode-specifics-alist valid)
        (when (derived-mode-p mode)
          (push specifics valid)))))

  (defun modal-toggle-state (&optional state)
    "Set `modal-state' and alter the local keymap.

  If STATE is non-nil, set `modal-state' to that; flip it otherwise."
    (if state
        (setq modal-state state)
      (modal--flip-state))
    (use-local-map
     (when (eq modal-state 'normal)
       (bind (make-sparse-keymap)
             (append-nested (list modal-bindings) (modal--get-specifics)))))
    (local-set-key modal-mode-exit-key #'modal-exit))

  (defun modal-insert (&optional arg)
    "Enter `insert' state from `normal'.

  When ARG is non-nil, ask for a string to repeat ARG times.  In this case, stay
  in `normal' state."
    (interactive "P")
    (modal-toggle-state 'insert)
    ;; Emulate Vi's insert mode with count.
    (when-let ((arg)
               (string (read-string (format "Repeat x%d: " arg)))
               (starting-size (buffer-size)))
      (dotimes (_ arg)
        (insert string))
      (unless (or (= (buffer-size) starting-size)
                  (string-match "^[[:space:]]+$" string))
        (delete-horizontal-space t))
      (modal-toggle-state 'normal)))

  (defun modal-exit ()
    "Return to `normal' state from `insert'.

  When already `normal', deactivate the mark and stop macro definition."
    (interactive)
    (when (eq modal-state 'normal)
      ;; Copied from `keyboard-quit':
      (deactivate-mark)
      (kmacro-keyboard-quit)
      (when defining-kbd-macro
        (force-mode-line-update t))
      (setq defining-kbd-macro nil))
    (modal-toggle-state 'normal))

  ;;;; Related modes.

  ;;;;; Modal.

  (define-minor-mode modal-mode
    "A minor mode that forces modal keybindings."
    :init-value nil
    :lighter " μ"
    :keymap (make-sparse-keymap)
    (if modal-mode
        (modal-toggle-state modal-state)
      (use-local-map nil)))

  ;;;;; Line-mark.

  (defvar line-mark-mode-map
    (let ((map (make-sparse-keymap)))
      (dolist (command '(next-line previous-line right-char
                                   left-char forward-char backward-char))
        (define-key map (vector 'remap command)
          (lambda ()
            (interactive)
            (call-interactively command)
            (line-mark--fix-point-and-mark))))
      map))

  (define-minor-mode line-mark-mode
    "Minor mode for selecting whole lines using `set-mark'."
    :init-value nil
    ;; Quite a bit of code was copied over from `rectangle-mark-mode'.
    (if (not line-mark-mode)
        (deactivate-mark)
      (add-hook 'deactivate-mark-hook (lambda () (line-mark-mode -1)))
      (unless (region-active-p)
        (push-mark (line-end-position) t t)
        (line-mark--fix-point-and-mark)
        (message "Mark set (line mode)"))))

  (defun line-mark--fix-point-and-mark ()
    "Make sure the mark and the point are in the right positions.

  There are two such 'positions': mark is in the beginning
  of a line, and the point is at the end and vice versa."
    (let* ((line (- (line-number-at-pos (mark)) (current-line)))
           (beginning (line-beginning-position line))
           (end (line-end-position line)))
      (cond
       ((> (point) beginning)
        (push-mark beginning t t)
        (goto-char (line-end-position)))
       ((< (point) end)
        (push-mark end t t)
        (goto-char (line-beginning-position))))))

  ;;;; Various commands.

  ;;;;; Context-sensitive (supplied prefix arg, or region is active).

  (defun eval-region-or-buffer ()
    "Evaluate region if it is active; evaluate whole buffer otherwise."
    (interactive)
    (if (use-region-p)
        (progn
          (eval-region (region-beginning) (region-end))
          (deactivate-mark))
      (eval-buffer)))

  (defun beginning-of-buffer-or-goto-line (&optional arg)
    "If ARG is supplied, go to that line.
  Go to the beginning of the buffer otherwise.

  Emulation of Vi's 'gg' command"
    (interactive "P")
    (if arg
        (goto-char (line-beginning-position arg))
      (goto-char (point-min))))

  (defun end-of-buffer-or-goto-line (&optional arg)
      "If ARG is supplied, go to that line.
  Go to the end of the buffer otherwise.

  Emulation of Vi's 'G' command"
    (interactive "P")
    (if arg
        (goto-char (line-beginning-position arg))
      (goto-char (point-max))))

  (defun kill-whole-line-or-region (&optional arg)
    "If region is active, kill it.  Otherwise, kill ARG (or the current) line(s)."
    (interactive "P")
    (if (use-region-p)
        (kill-region (region-beginning) (region-end))
      (kill-whole-line arg)))

  ;;;;; Combined.

  (defun open-line-and-insert ()
    "Call `open-line' and enter `insert' state."
    (interactive)
    (call-interactively #'open-line)
    (modal-insert))

  (defun newline-and-insert ()
    "Call `newline' and enter `insert' state."
    (interactive)
    (call-interactively #'newline)
    (modal-insert))

  (defun end-of-line-and-insert ()
    "Enter `insert' state after calling `end-of-line'."
    (interactive)
    (call-interactively #'end-of-line)
    (modal-insert))

  (defun beginning-of-line-and-insert ()
    "Enter `insert' state after calling `beginning-of-line'."
    (interactive)
    (call-interactively #'beginning-of-line)
    (modal-insert))

  ;;;;; Vi-like '/' search.

  (defvar-local modal-search-query nil)

  (defun modal-can-search-p ()
    "Return nil if user should be prompted for a search query."
    (and modal-search-query
         (not (string-empty-p modal-search-query))))

  (defun modal-search (&optional backwards)
    "Ask for a search query and move to the next match forwards.

  If BACKWARDS is non-nil, move to the next match backwards instead."
    (interactive "i")
    (when-let ((query (read-string "/")))
      (setq modal-search-query query)
      (if backwards
          (modal-search-prev)
        (modal-search-next))))

  (defun modal-search-next ()
    "Go to next match, prompting for a query if there is none."
    (interactive)
    (if (modal-can-search-p)
        (search-forward-regexp modal-search-query)
      (modal-search nil)))

  (defun modal-search-prev ()
    "Go to previous match, prompting for a query if there is none."
    (interactive)
    (if (modal-can-search-p)
        (search-backward-regexp modal-search-query)
      (modal-search t)))

  ;;;;; File operations.

  (defun rename-buffer-file (buffer new-name)
    "Rename BUFFER's file to NEW-NAME and re-open it."
    (interactive (list (current-buffer) (read-file-name "New name: ")))
    (let ((file (buffer-file-name buffer)))
      (unless file
        (user-error "Buffer is not assigned to a file"))
      (unless (file-exists-p file)
        (user-error "Buffer file doesn't exist.  Did you forget to save it?"))
      (rename-file file new-name t)
      (let ((kill-buffer-query-functions (list)))
        (kill-buffer buffer))
      (find-file new-name)))

  (defun delete-buffer-file (buffer)
    "Kill BUFFER (or the current buffer) after deleting its file."
    (interactive (list (current-buffer)))
    (let ((file (buffer-file-name buffer)))
      (unless file
        (user-error "Buffer is not assigned to a file"))
      (when (file-exists-p file)
        (delete-file file t))
      (kill-buffer buffer)))

  (defun modal--special-buffer-p ()
    "Return non-nil if the current buffer is considered 'special'."
    (or (derived-mode-p 'special-mode 'Info-mode)
        (string= (buffer-name) "*scratch*")))

  (defun modal-save-buffer (&optional arg)
    "Like `save-buffer', but doesn't save special buffers.

  Run with prefix arg ARG to force saving a buffer in this case.

  See `modal--special-buffer-p'."
    (interactive "P")
    (if (or (equal arg '(4)) (not (modal--special-buffer-p)))
        (save-buffer 0)
      (message (concat "Run with prefix arg to "
                       (propertize "really" 'face 'italic)
                       " save the buffer"))))

  ;;;;; Misc.

  (defun indent-right (count)
    "Indent COUNT level right."
    (interactive "p")
    (setq count (* count standard-indent))
    (if (use-region-p)
        (indent-rigidly (region-beginning) (region-end) count)
      (indent-rigidly (line-beginning-position) (line-end-position) count)))

  (defun indent-left (count)
    "Indent COUNT levels left."
    (interactive "p")
    (indent-right (- count)))

  (defun repeat-region (arg start end)
    "Repeat the text between START and END ARG times."
    (interactive "p\nr")
    (dotimes (_ arg)
      (insert (buffer-substring start end))))

  (defun modal-scroll-up (&optional arg)
    "Scroll up half a screenful ARG times."
    (interactive "p")
    (let ((lines (/ (window-text-height) 2)))
      (recenter (if (< arg 0) -1 0))
      (forward-line (if arg (* lines arg) lines))))

  (defun modal-scroll-down (&optional arg)
    "Scroll down half a screenful ARG times."
    (interactive "p")
    (modal-scroll-up (- arg)))

  (defun s/ (pattern new-name &optional search-fun)
    "Replace PATTERN with NEW-NAME, using SEARCH-FUN to match.

  SEARCH-FUN defaults to `re-search-forward', mostly for interactive calls.  It
  must always search forwards.

  Suitable for non-interactive use."
    (interactive "ss/\nss/%s/")
    (unless search-fun
      (setq search-fun #'re-search-forward))
    (let ((old-point (point)))
      (goto-char (point-min))
      (while (funcall search-fun pattern nil t)
        (replace-match new-name))
      (goto-char old-point)))

  (defun modal-rename-symbol ()
    "Rename symbol at point.

  If `eglot' is active, rename using the language server.
  Otherwise, replace text blindly."
    (interactive)
    (if-let ((symbol (symbol-at-point)))
        (if (eglot-managed-p)
            (call-interactively #'eglot-rename)
          (when-let* ((string (symbol-name symbol))
                      (prompt (format "Rename %s to: " string))
                      (new-name (read-string prompt)))
            (s/ string new-name #'search-forward)))
      (user-error "No symbol at point")))

  ;;;;; Movement-key combos.

  (defun replace-character-or-region ()
    "If region is set, kill it and enter `insert' state.

  Otherwise, prompt for a character and replace with it the one at point."
    (interactive)
    (if (use-region-p)
        (if (bound-and-true-p rectangle-mark-mode)
            (call-interactively #'string-rectangle)
          (call-interactively #'kill-region)
          (modal-insert))
      (when-let ((char (read-char "Replace with: ")))
        (replace-region-contents
         (point) (1+ (point))
         (lambda ()
           (char-to-string char))))))

  (defun move-and-kill (old-point)
    "Kill everything between OLD-POINT and point."
    (kill-region old-point (point)))

  (defun move-and-replace (old-point)
    "Kill everything between OLD-POINT and point, and enter `insert' state."
    (move-and-kill old-point)
    (modal-insert))

  (defun move-and-yank (old-point)
    "Save to kill ring everything between OLD-POINT and point."
    (kill-ring-save old-point (point)))

  (defun kill-ring-save-region-or-line ()
    "If region is active, save it to the kill ring.  Save current line otherwise."
    (interactive)
    (if (use-region-p)
        (call-interactively #'kill-ring-save)
      (kill-ring-save (line-beginning-position) (line-end-position))))

  ;;;; Key definitions.

  ;;;;; Internals.

  (defun modal--echo (format-string &rest args)
    "Display a message in echo area, without logging it to messages buffer.

  Used in `modal-combo' to display pressed keys.

  FORMAT-STRING and ARGS are used just like in `message'."
    (let ((message-log-max nil))
      (apply #'message format-string args)))

  (defun modal-combo (key move-fun &optional dwim-fun)
    "Return a keys-alist entry which expects a key combo.

  The CAR is KEY.  The CDR is a lambda which:
   ,* Calls DWIM-FUN if DWIM-FUN is supplied and KEY is pressed twice.
   ,* Calls MOVE-FUN if the point value has changed after a key combo.

  DWIM-FUN is a command.  MOVE-FUN is a command which
  takes one argument: the previous point value."
    (cons key
          (lambda ()
            (interactive)
            (let ((old-point (point))
                  (sequence
                   (progn
                     (modal--echo "%s-" key)
                     (read-key-sequence nil))))
              (modal--echo "%s-%s" key (key-description sequence))
              (when-let ((command (key-binding sequence)))
                (if (and dwim-fun (eq this-command command))
                    (call-interactively dwim-fun)
                  (call-interactively command)
                  (when (/= (point) old-point)
                    (funcall move-fun old-point))))))))

  ;;;;; Variables.

  (setq modal-bindings
        `(("h" . backward-char)
          ("j" . next-line)
          ("k" . previous-line)
          ("l" . forward-char)
          ("J" . scroll-up-line)
          ("K" . scroll-down-line)
          ("a" . beginning-of-line)
          ("e" . end-of-line)
          ("T" . back-to-indentation)
          ("H" . backward-sexp)
          ("L" . forward-sexp)
          ("w" . forward-word)
          ("b" . backward-word)
          ("(" . sp-backward-sexp)
          (")" . sp-forward-sexp)
          ("G" . end-of-buffer-or-goto-line)
          ("g" . (("g" . beginning-of-buffer-or-goto-line)
                  ("l" . avy-goto-line)
                  ("w" . avy-goto-word-1)
                  ("c" . avy-goto-char)))
          ("i" . modal-insert)
          ("A" . beginning-of-line-and-insert)
          ("E" . end-of-line-and-insert)
          ("o" . open-line-and-insert)
          ("m" . newline-and-insert)
          ("x" . delete-char)
          ("X" . delete-backward-char)
          ("f" . delete-indentation)
          ("s" . helm-swoop)
          ("S" . helm-multi-swoop-projectile)
          ("q" . kmacro-start-macro-or-insert-counter)
          ("Q" . kmacro-end-macro)
          ("@" . kmacro-end-and-call-macro)
          ("Z" . yas-expand)
          ("u" . undo)
          ("v" . set-mark-command)
          ("V" . line-mark-mode)
          ("C-v" . rectangle-mark-mode)
          ("D" . kill-line)
          ("p" . yank)
          (";" . comment-line)
          ("t" . indent-for-tab-command)
          ("F" . fill-paragraph)
          ("R" . repeat-region)
          ("c" . recenter-top-bottom)
          ("z" . cycle-spacing)
          ("/" . modal-search)
          ("n" . modal-search-next)
          ("N" . modal-search-prev)
          ("#" . insert-file)
          ("," . indent-left)
          ("." . indent-right)
          ("C-n" . modal-scroll-up)
          ("C-p" . modal-scroll-down)
          ("+" . text-scale-increase)
          ("-" . text-scale-decrease)
          ("0" . "C-0")
          ("1" . "C-1")
          ("2" . "C-2")
          ("3" . "C-3")
          ("4" . "C-4")
          ("5" . "C-5")
          ("6" . "C-6")
          ("7" . "C-7")
          ("8" . "C-8")
          ("9" . "C-9")
          ,(modal-combo "d" #'move-and-kill #'kill-whole-line-or-region)
          ,(modal-combo "r" #'move-and-replace #'replace-character-or-region)
          ,(modal-combo "y" #'move-and-yank #'kill-ring-save-region-or-line)
          (":" . (("w" . modal-save-buffer)
                  ("q" . kill-current-buffer)
                  ("s" . s/)
                  ("x" . helm-M-x)))
          ("SPC" . (("g" . magit-status)
                    ("u" . list-packages)
                    ("p" . ,projectile-command-map)
                    ("f" . helm-find-files)
                    ("b" . helm-buffers-list)
                    ("h" . ,help-map)
                    ("F" . eglot-code-actions)
                    ("r" . modal-rename-symbol)
                    ("d" . eldoc-doc-buffer)
                    ("w" . eww)
                    ("v" . reset-variable)
                    ("j" . flymake-goto-next-error)
                    ("k" . flymake-goto-prev-error)
                    ("e" . eval-region-or-buffer)
                    ("E" . eval-defun)
                    ("/" . dabbrev-expand)
                    ("o" . org-preview-html-mode)
                    ("x" . org-html-export-to-html)
                    ("'" . org-edit-src-exit)
                    ("C-r" . rename-buffer-file)
                    ("C-d" . delete-buffer-file)))))

  (setq modal-mode-specifics-alist
        '((eww-mode . (("H" . eww-back-url)
                       ("L" . eww-forward-url)
                       ("t" . eww)
                       ("z" . eww-copy-page-url)
                       ("<M-return>" . eww-open-in-new-buffer)))
          (special-mode . (("q" . quit-window)))
          (help-mode . (("<" . help-go-back)
                        (">" . help-go-forward)
                        ("RET" . help-follow)))
          (Info-mode . (("q" . quit-window)
                        ("H" . Info-prev)
                        ("L" . Info-next)
                        ("<" . Info-history-back)
                        (">" . Info-history-forward)
                        ("^" . Info-up)
                        ("RET" . Info-follow-nearest-node)))
          (org-mode . (("f" . org-cycle)
                       ("SPC" . (("SPC" . org-edit-special)
                                 ("j" . org-next-visible-heading)
                                 ("k" . org-previous-visible-heading)
                                 ("J" . org-forward-heading-same-level)
                                 ("K" . org-backward-heading-same-level)))))))

  ;;;; Hooks.

  (dolist (mode '(prog text conf help apropos Info eww))
    (add-hook (s-concat mode "-mode-hook") #'modal-mode))
#+END_SRC

* EXWM Configuration

#+BEGIN_SRC emacs-lisp
;;;; Keybindings.

(defun exec ()
  "Execute a command asynchronously."
  (interactive)
  (sh (read-shell-command "$ ") 0))

(defun exec-buf ()
  "Execute a command similarly to `exec', showing its output in a buffer."
  (interactive)
  (with-output-to-temp-buffer "*Command output*"
    (sh (read-shell-command "$ ") standard-output)))

(defun sh-binding (command)
  "Return a lambda running `sh' with COMMAND.  Useful for setting up keys."
  `(lambda () (interactive) (sh ,command 0)))

(defun mpd-binding (command &rest args)
  "Like `sh-binding', but call `mpd-control' with COMMAND and ARGS."
  (sh-binding (format "mpd-control %s %s" command (string-join args " "))))

(defun download-track (url)
  "Download a music track from URL, using `mpd-control'."
  (interactive "sURL: ")
  ;; Quote the URL in case it contains weird characters.
  (funcall (mpd-binding "download" (format "'%s'" url))))

(defun quick ()
  "Launch a program or utility from a `helm' listing."
  (interactive)
  (when-let*
      ((quick '(("Browser"    . "qutebrowser --no-err-windows")
                ("Discord"    . "discord")
                ("Parsec"     . "parsecd app_daemon=1")
                ("Moonlight"  . "moonlight")
                ("Steam"      . "steam")
                ("Doomseeker" . "doomseeker")
                ("Torrent"    . "transmission-gtk")
                ("PA Volume"  . "pavucontrol")
                ("Zoom"       . "zoom")
                ("Aria"       . "Aria")))
       (utils '(("Restart fluidsynth" . "systemctl --user restart fluidsynth")
                ("Restart mpd" . "systemctl --user restart mpd && mpd-control play")
                ("SSH proxy to tilde" . "ssh -ND 9050 nonk@tilde.as205315.net")
                ("Kill all SSH connections" . "pkill ssh")))
       (command (helm
                 :prompt "Launch: "
                 :buffer "*Program selection*"
                 :sources
                 (vector
                  (helm-build-sync-source "Quick launch"
                    :candidates quick)
                  (helm-build-sync-source "Utilities"
                    :candidates utils)))))
    (sh command 0)))

;;;; Window layouts.

(defvar window-layout-defs
  '(("d" . ())
    ("b" . ())
    ("c" . (:right my-term :below my-term))
    ("t" . (my-term))
    ("i" . ())
    ("1" . ())
    ("2" . ())
    ("3" . ()))
  "Description of window layouts created on EXWM startup.")

(defvar layout-mappings '())

(defun generate-layouts ()
  "Generate EXWM frames from `window-layout-defs'."
  (dolist (def window-layout-defs)
    (set-buffer "*scratch*") ; *scratch* is the starting buffer
    (let ((workspace (exwm-workspace-add)))
      (dolist (token (cdr def))
        (cl-typecase token
          (keyword        ; :right and :below just split the current window
           (select-window ; this makes the split window current
            (cond
             ((eq token :right)
              (split-window-right))
             ((eq token :below)
              (split-window-below))
             (t
              (user-error "Unrecognized token: %s" token)))))
          (t
           (funcall token)))) ; call symbols and lambdas (untested)
      ;; Save the frame for use in `select-layout'.
      (add-to-list 'layout-mappings (cons (car def) workspace)))))

(defun select-layout ()
  "Ask user to select a layout from `layout-mappings'."
  (interactive)
  (unless layout-mappings ; create the frames on first call
    (generate-layouts))
  (if-let* ((letter (read-key "Layout: "))
            (letter (key-description (list letter))) ; strings are used as keys
            (mapping (assoc letter layout-mappings))
            (workspace (cdr mapping))
            ;; Bail out if the frame is dead.
            (workspace (when (frame-live-p workspace) workspace)))
      (exwm-workspace-switch workspace)
    (user-error "Not a layout")))

(defun copy-10 ()
  "Enter a Unicode character's base-10 value and copy it to clipboard."
  (interactive)
  (with-temp-buffer
    (let ((read-quoted-char-radix 10))
      (quoted-insert 1)
      (clipboard-kill-ring-save (point-min) (point-max)))))

(defun copy-unicode ()
  "Search for a Unicode character and copy it to clipboard."
  (interactive)
  (with-temp-buffer
    (call-interactively #'insert-char)
    (clipboard-kill-ring-save (point-min) (point-max))))

;;;; `use-package' declaration.

(use-package exwm
  :init
  ;; Easy window-switching with s-b.
  (setq exwm-workspace-show-all-buffers t)
  (setq exwm-layout-show-all-buffers t)
  ;; C-c is a prefix key; send ^C with C-c C-c.
  (setq exwm-input-simulation-keys '(([?\C-c ?\C-c] . ?\C-c)))
  (setq exwm-input-global-keys
        (mapcar
         (lambda (binding)
           (cons (kbd (car binding)) (cdr binding)))
         `(("s-h" . windmove-left) ; basic movement keys
           ("s-j" . windmove-down)
           ("s-k" . windmove-up)
           ("s-l" . windmove-right)
           ("C-s-h" . ,(exchange-window #'windmove-left)) ; swap buffers
           ("C-s-j" . ,(exchange-window #'windmove-down))
           ("C-s-k" . ,(exchange-window #'windmove-up))
           ("C-s-l" . ,(exchange-window #'windmove-right))
           ("M-s-h" . shrink-window-horizontally) ; weird resize
           ("M-s-j" . enlarge-window)
           ("M-s-k" . shrink-window)
           ("M-s-l" . enlarge-window-horizontally)
           ("s-n" . split-window-below) ; obviously, window-splits
           ("s-m" . split-window-right)
           ("s-w" . delete-window)     ; kill a window (buffer is left behind)
           ("s-q" . force-kill-buffer) ; kill a buffer
           ("s-b" . switch-to-buffer)  ; select a buffer
           ("s-f" . exwm-layout-toggle-fullscreen) ; window modes
           ("s-r" . exwm-floating-toggle-floating)
           ("s-g" . exwm-input-toggle-keyboard) ; char and line mode switch
           ("s-i" . load-init)     ; reload init file
           ("s-v" . select-layout) ; change workspace
           ("s-'" . copy-unicode)  ; weird stuff
           ("s-0" . copy-10)
           ("s-s" . exwm-input-send-next-key)
           ("s-e" . exec)
           ("s-E" . exec-buf)
           ("<s-return>" . my-term) ; common programs
           ("<print>" . ,(sh-binding "screenshot"))
           ("s-d" . quick) ; dmenu-like prompt
           ("s-p" . ,(mpd-binding "select")) ; music
           ("s-," . ,(mpd-binding "prev"))
           ("s-." . ,(mpd-binding "next"))
           ("s-o" . ,(mpd-binding "toggle"))
           ("s-;" . ,(mpd-binding "clear"))
           ("s-[" . ,(mpd-binding "status"))
           ("s-]" . ,(mpd-binding "single"))
           ("s-ä" . ,(mpd-binding "seek -8"))
           ("s-$" . ,(mpd-binding "seek +8"))))))

;;;; EXWM magic.

(defun exwm-update-class-actions ()
  (unless exwm-title
    (exwm-workspace-rename-buffer exwm-class-name)))
(add-hook 'exwm-update-class-hook #'exwm-update-class-actions)

(defun exwm-update-title-actions ()
  (exwm-workspace-rename-buffer exwm-title))
(add-hook 'exwm-update-title-hook #'exwm-update-title-actions)

(defvar exwm-enabled nil
  "Non-nil if `start-exwm' was run.")

(defun exwm-update-input ()
  "Re-bind EXWM keys after `exwm-input-global-keys' update."
  (dolist (binding exwm-input-global-keys)
    (exwm-input--set-key (car binding) (cdr binding))))

(defun exwm-init-actions ()
  "Hook run when the EXWM session is initialized."
  (use-package humanoid-themes)
  (load-theme 'humanoid-dark t)
  (set-frame-font "Hack 10" nil t)
  (unbind global-map "C-z") ; can't hide EXWM frames
  (setq exwm-enabled t))
(add-hook 'exwm-init-hook #'exwm-init-actions)

(add-hook 'exwm-exit-hook (lambda () (setq exwm-enabled nil)))

(defun start-exwm ()
  "Start EXWM session.  Used in .xinitrc."
  (exwm-enable)
  (scroll-bar-mode 0)
  (fringe-mode 0))

;; If EXWM is still running, re-bind the keys.
(when exwm-enabled
  (exwm-update-input))
#+END_SRC

* Miscellaneous

#+BEGIN_SRC emacs-lisp
(c-add-style "nonk123"
             '("java"
               (c-basic-offset . 4)
               (c-offsets-alist ((access-label . /)
                                 (case-label . +)))))

(setq c-default-style
      '((java-mode . "java")
        (awk-mode . "awk")
        (other . "nonk123")))

(setq inhibit-startup-message t)

(setq-default
 indent-tabs-mode nil
 tab-stop-list nil
 epa-pinentry-mode 'loopback
 vc-follow-symlinks t
 major-mode #'prog-mode)

(menu-bar-mode 0)
(tool-bar-mode 0)

(blink-cursor-mode 0)

(setq display-time-day-and-date t)
(display-time-mode 1)

(delete-selection-mode 1)

(show-paren-mode 1)

(column-number-mode 1)
#+END_SRC
